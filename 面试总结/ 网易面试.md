# 一面：
### 1.箭头函数特性：
    1.对 this 的关联。函数内置 this 的值，取决于箭头函数在哪儿定义，而非箭头函数执行的上下文环境。
    2.new 不可用。箭头函数不能使用 new 关键字来实例化对象，不然会报错。
    3.this 不可变。函数内置 this 不可变，在函数体内整个执行环境中为常量。
    4.没有arguments对象。更不能通过arguments对象访问传入参数。只能使用显式命名或其他ES6新特性来完成。

### 2.es5实现类？类有什么特性？
    类中定义的方法都定义在prototype对象上
    类的实例化对象只能通过new
    类的所有实例共享一个原型对象
    类不存在变量提升
    类相当于实例化原型，设置的所有方法都会被实例继承，如果在方法前加一个static，则不会被实例继承，只可以通过extend被下一个类继承调用。

### 3.gulp之行过程？打包原理？
    1.
         1.先全局安装gulp
         2.作为项目的开发依赖安装3.
         3.接着创建一个gulpile.js,
               var gulp = require(‘gulp’);
               gulp.task(‘default’, function() {
                    //将默认的任务代码放在这里
                });
         4.最后运行gulp    

    2.读取文件－－》 代码检查 －－》
    合并多个文件(当利用前端组件化开发时，就可能把一个文件分成很多个小文件，这时候可能一次并发操作只能执行5个文件，而我们有20个，这时候很明显会影响网页的性能，因此需要对文件进行一次合并)
     －－》压缩

### 4.两边定宽，中间自适应

### 5.垂直居中

### 6.js阻止时间冒泡，ie的兼容如何解决？

### 7.浏览器兼容方面举例子

### 8.发送http到返回数据的完整过程

### 9.原生js实现ajax
    通过调用xmlhttprequest对象，然后利用它的open方法发送数据给服务器，接着通过onreadystatechange事件的readyState去判断当前状态和status http状态码去判断信息，然后利用responseText或者responseXML去操作响应的信息。


### 10.jsonp跨域原理？对http，url有什么要求？

### 11.react实现过哪些组件？

### 12.css选择器有哪些？优先级？

### 13.包之间通过什么方法进行相互依赖调用？

### 14.scss如何使用？scss如何进行包的依赖调用
    web pack内置了sass-loder，通过安装依赖就可以使用了。

### 15.原型链
    我们每次创建对象时都会生成一个__proto__的内置属性去指向创建该对象的原型对象prototype,然后我们把__proto__串起来，直到object.prototype.__proto__为null的链叫做原型链。

### 16.继承方式有哪些？apply和call的区别？
     apply和call的作用都是继承属性并修改了this的指向；区别在于二者传递的参数不同，apply为 数组而call为一个对象。

### 17.解释Promise对象？
 promise是针对异步编程的一种解决方案，拥有peding(进行中),resolved(已完成),rejected(已失败)三种状态，且状态不受外界影响，一旦改变，就不会再变。
用法方面是 new 一个promise对象，该对象会提供两个参数，利用then方法去分别指定resolve的返回函数(第一个)，和reject的返回函数(第二个)

### 18.解构
从数组和对象中提取值，对变量进行赋值。

### 19.webpack的原理？优缺点？
    web pack主要是三个特点：  模块化， 处理依赖， 打包
    它会将复杂的程序细化为更小的且易于管理的文件模块，从而达到重复利用的目的。
    它不像传统打包工具编译生成一个庞大的bundle.js文件，它会将其拆分成多个bundle.js,按需加载。

### 20.事件模型？事件流的三个阶段？
    事件模型有
        1. domo:直接在dom对象上注册事件名称，一个dom对象只能注册一个同类型的函数，否则多个会被
                     覆盖。
        2.dom2(IE8之前版本不支持)好处是一个对象可以注册多个相同类型的事件而不会发生覆盖
                dom2事件流： 先捕获  再到达目标节点 最后冒泡

        3.阻止事件冒泡的方法
                1.stopPropgation()
                2. 针对ie: window.event.cancelBubble

        4.阻止默认行为
                1.preventDefault()
                2.windows.event.returnValue = false



# 二面：

### 1.什么叫无状态组件？
    1.组件只负责根据传入的props来展示，不涉及state状态的操作，
    2.该组件没有访问生命周期的方法
    3.该组件不会被实例化，因此渲染能力较高

### 2.react优化
    1.通过key，比如利用map设置li时，就要给每一个li设置key值，当某个li被改变时，key值就会变化，不变的key则不用重新渲染，只用去改变变化key值的li
    2.componentDidUpdate，在其中写一个判断，返回false,则该组件以及它的子组件不需要再生成新的虚拟dom;
    返回true则需继续向叶子节点检查，检查到某个叶子节点返回false,则是因为虚拟dom不相等，需要被更新。

    使用PureRenderMixin、shouldComponentUpdate来避免不必要的虚拟DOM diff，在render内部优化虚拟DOM的diff速度，以及让diff结果最小化。

    PureRenderMixin的原理就是它实现了shouldComponentUpdate，在shouldComponentUpdate内它比较当前的props、state和接下来的props、state，当两者相等的时候返回false，这样组件就不会进行虚拟DOM的diff。

    PureRenderMixin主要用在简单的数据结构比较当前的props、state和接下来的props、state

    shouldComponentUpdate则是用在复杂的数据结构中进行比较

    使用immutable.js解决复杂数据diff、clone等问题。

    3.因为react第一次渲染速度较慢，所以可以通过h5的应用程序缓存  mainfest，这样以后的访问速度就会显著加快

### 3.创建组件的三种方式：
     1.创建‘无状态组件’
     2.es5原生通过  React.creatClass 定义组件
     3.es6通过  extend React.component 定义组件


### 4.安全性


### 5.性能优化
    1.将脚本内容在页面信息内容加载后再加载,
    2.代码级优化
    3.服务器使用cdn:cdn通过部署在不同区域的服务器来提高用户的下载速度
    4.减少dom数量
    5.压缩传输文件
    6.ajax方法中尽量用get而少用post，因为get可以直接通过tcp报文完成请求，而post则要分成两部先发header再发送数据。

### 6.兼容性
    很多兼容问题都是由于不同的浏览器对标签的默认属性解析的不同而导致的，
    现在由于大家都基本要求兼容到ie8以上就可以，所以造成很多样式不兼容，往往就是一些css3新增属性
    如我喜欢用的borde-redius,box－shadow要ie-9以上才支持，新的伸缩盒布局flex更是要ie11以上chrome21+才支持，
    动画套装也是要在ie10以上才支持；

### 7.闭包的理解？作用？
    闭包就是能够读取其他函数内部变量的函数。
    作用：
    1.由于外部无法引用内部变量，我们可以写一个函数，然后它在执行完毕后很快就会被释放，从而不会污染全局
    2.进行缓存，让所需要的信息一致保存在内存中。
    3.实现封装，确保有些信息的安全性。
