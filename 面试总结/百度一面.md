# 一 面：
## 1. 造成js内存泄漏原因
## 2. 前端调试方式，调试工具
    1. 正常就使用chrome的调试工具

## 3. 图片处理手段
    1. 图片压缩
    2. 缩略图法，鼠标触碰时变清晰
    3. 预加载
## 4. 垂直居中方法  水平居中方法
    1. flex布局的垂直水平居中的方法：父盒子：display: flex; justify-content: center; align-items: center;
    2. 定位解决水平垂直居中:当前盒子：margin:0 auto;position:relative;top: 50%;transform: translateY(-50%);
    3. 表格解决：父盒子：display: table; 自盒子：display:table-cell; vertical:middle;
## 5. get和post区别
    1. //get
        1. 从服务器上请求资源
        2. 请求可以被缓存
        3. 请求可以保留在历史记录中
        4. 会显示在浏览器地址栏中，不应在处理敏感数据时使用
        5. 有长度限制，主要是URL长度的限制，最大2048kb
    2. //post
        1. 向服务器提交要被处理的数据
        2. 不能保留在历史记录中
        3. 对数据的请求长度没有限制
        4. 数据不会显示找URL中
## 6. 跨域
## 7. css3属性
## 8. flex布局
## 9. doctype
## 10. 网页编码格式：utf-8，gbk(通用性比utf8差，但是占用数据库量比utf8小),必须通过unicode编码才可以相互转换
## 11. js数据类型
    1. 6 种 原始类型:
        * Boolean
        * Null
        * Undefined
        * Number
        * String
        * Symbol (ECMAScript 6 新定义)
    2. 和 Object
## 12. html5标签
## 13. 内联元素与块级元素
    1.块级元素和行内元素的区别是，块级元素会占一行显示，
    而行内元素可以在一行并排显示。通过样式控制，
    它们可以相互转换。
    块级元素和行内元素之间的一个重要的不同点：尺寸。
        * 设置宽度 width 无效；
        * 设置高度 height 无效，可以通过 line-height 来设置；
        * 设置 margin 只有左右 margin 有效，上下无效；
        * 设置 padding 只有左右 padding 有效，上下则无效。
        注：无效指它对其它元素的排列没有影响。也就是说，对于设
        置的 margin，padding 行内元素文档流里的上下元素来
        说，他们的间距不会因为上下 margin 或者上下 padding
        而产生间距。但是就他本身而言，对于上下 margin 与padding
        是有效的。


## 14. arguments
    1. 在JavaScript中，arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性
    2. arguments对象的长度是由实参个数而不是形参个数决定的。
    3. arguments对象中有一个非常有用的属性：callee。arguments.callee返回此arguments对象所在的当前函数引用。
## 15. 判断js对象是否拥有某种属性的方式
    1. in 运算符

    ```JavaScript
    var obj = {name:'jack'};
    alert('name' in obj); // --> true
    alert('toString' in obj); // --> true
    可看到无论是name，还是原形链上的toString，都能检测到返回true。
    ```  
    2. hasOwnProperty 方法
    ```JavaScript
    var obj = {name:'jack'};
    obj.hasOwnProperty('name'); // --> true
    obj.hasOwnProperty('toString'); // --> false
    当然重写原型后for in在IE9/Firefox/Safari/Chrome/Opera下是可见的。
    ```
    原型链上继承过来的属性无法通过hasOwnProperty检测到，返回false。
    需注意的是，虽然in能检测到原型链的属性，但for in通常却不行。

## 16. jsonp跨域原理 为什么可以script标签跨域
## 17. css显示和隐藏
## 18. ajax的运行过程
## 19. xmlhttp.open的参数个数
## 20. 3xx重定向过程
## 21. http方法
    GET     请求获取Request-URI所标识的资源
    POST    在Request-URI所标识的资源后附加新的数据
    HEAD    请求获取由Request-URI所标识的资源的响应消息报头
    PUT     请求服务器存储一个资源，并用Request-URI作为其标识
    DELETE  请求服务器删除Request-URI所标识的资源
    TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断
    CONNECT 保留将来使用
    OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求
## 22. 阻止浏览器默认行为的方法
    1. w3c的方法是e.preventDefault()
    2. IE则是 e.returnValue=false
## 23. 事件代理方法？事件委托？
    1. 事件委托： 利用事件冒泡机制，通过给父级设置监听，然后检查事件的来源，找到是哪个子元素的事件，这样可以避免对特定的每个节点设置监听器。
## 24. 事件模型 事件捕获与事件冒泡
## 25. a标签的四个伪类，顺序，如何禁止跳转
    1.
      ① a:link：未访问链接 ,如 a:link {color:blue}
      ② a:visited：已访问链接 ,如 a:visited{color:blue}
      ③ a:active：激活时（链接获得焦点时）链接的颜色 ,如a:active{color:blue}
      ④ a:hover：鼠标移到链接上时 ,如 a:hover {color:blue}
      一般a:hover和a:visited链接的状态（颜色、下划线等）应该是相同的。
      前三者分别对应body元素的link、vlink、alink这三个属性。
    2. 四个“状态”的先后过程是：
    a:link ->a:hover ->a:active ->a:visited。
## 26. 引用标签
## 27. doctype
## 28. 函数继承的五种方式
## 29. 组件化和模块化
    1. 模块化侧重于功能或者数据的封装，一组相关的组件可以定义成一个模块
    2. 组件化更多关注的是UI部分，你看到的一个管理界面的弹出框，
    头部，内容区，确认按钮和页脚都可以是个组件，这些组件可以组成一个弹出框组件，跟其他组件组合又是一个新的组件

## 30.bfc块级格式化上下文
